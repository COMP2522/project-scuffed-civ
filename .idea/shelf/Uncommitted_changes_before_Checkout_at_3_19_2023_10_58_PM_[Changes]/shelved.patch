Index: src/main/java/org/bcit/com2522/project/scuffed/client/GameState.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.bcit.com2522.project.scuffed.client;\r\n\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\nimport org.json.simple.parser.JSONParser;\r\nimport org.json.simple.parser.ParseException;\r\nimport processing.core.PVector;\r\n\r\nimport java.io.*;\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\nimport java.util.stream.Collectors;\r\n\r\nimport static processing.core.PConstants.*;\r\n\r\npublic class GameState { //everything manager this is the player manager\r\n    int gameId;\r\n    Map map;\r\n    Player currentPlayer;\r\n    ArrayList<Player> players;// could be a circular linked list instead might make logic easier\r\n    Entity[][] entities;\r\n    Entity selected;\r\n    Window scene;\r\n\r\n    int zoomAmount;\r\n\r\n    public GameState(Window scene, int numplayers, int mapwidth, int mapheight) {\r\n        this.gameId = new Random().nextInt(10000); //make a random gameId\r\n        players = new ArrayList<Player>();\r\n        this.scene = scene;\r\n\r\n        entities = new Entity[mapwidth][mapheight];\r\n        map = new Map(scene, mapwidth, mapheight);\r\n\r\n        //scale = 1;\r\n\r\n        for(int i = 0; i < numplayers; i++) {\r\n            players.add(new Player(scene, i));\r\n        }\r\n\r\n        zoomAmount = 32;\r\n\r\n        init(); //inits players and starting entities on map\r\n    }\r\n\r\n    public GameState(){\r\n        zoomAmount = 32;\r\n    };\r\n\r\n    public void init() {\r\n        //this is just for now more logic will have to go into making players later\r\n        currentPlayer = players.get(0);\r\n\r\n        //puts entities into each corner\r\n        if(players.size() > 0) {\r\n            entities[0][0] = new Worker(scene, new Position(0, 0), players.get(0));\r\n        }\r\n        if(players.size() > 1) {\r\n            entities[entities.length - 1][entities[0].length - 1] = new Worker(scene, new Position(entities.length - 1, entities[0].length - 1), players.get(1));\r\n        }\r\n        if(players.size() > 2) {\r\n            entities[entities.length - 1][0] = new Worker(scene, new Position(entities.length - 1, 0), players.get(2));\r\n        }\r\n        if(players.size() > 3) {\r\n            entities[0][entities[0].length - 1] = new Worker(scene, new Position(0, entities[0].length - 1), players.get(3));\r\n        }\r\n        if(players.size() > 4) {\r\n            entities[(entities.length - 1) / 2][0] = new Worker(scene, new Position((entities.length - 1) / 2, 0), players.get(4));\r\n        }\r\n        if(players.size() > 5) {\r\n            entities[(entities.length - 1) / 2][entities[0].length - 1] = new Worker(scene, new Position((entities.length - 1) / 2, entities[0].length - 1), players.get(5));\r\n        }\r\n//        if(players.size() > 6) {\r\n//            entities[0][0] = new Worker(scene, new Position(0, 0), currentPlayer);\r\n//        }\r\n//        if(players.size() > 7) {\r\n//            entities[0][0] = new Worker(scene, new Position(0, 0), currentPlayer);\r\n//        }\r\n    }\r\n\r\n    public void clicked(PVector mousePos) {\r\n        Position position = new Position((int) (mousePos.x / 32), (int) (mousePos.y / 32));\r\n\r\n        if (mousePos.x >= 700 && mousePos.y >= 500) { //position of nextTurn button\r\n            save();\r\n            nextTurn();\r\n        }\r\n\r\n        //TODO everything below this should be mathed out and shortened\r\n        else if(entities[position.getX()][position.getY()] == null && selected == null) { //make new entity\r\n            //players.get(currentTurn.getPlayerNum()).addEntity(position);\r\n            //entities[position.getX()][position.getY()] = new Entity(scene, position, currentPlayer);\r\n            System.out.println(\"You can't make entities like that!\");\r\n        } else if (entities[position.getX()][position.getY()] != null &&\r\n                entities[position.getX()][position.getY()].getOwner() == currentPlayer) { //select existing entity\r\n            //.getOwner().equals(currentTurn)\r\n            selected = entities[position.getX()][position.getY()];\r\n            System.out.println(\"selected\");\r\n        } else if (entities[position.getX()][position.getY()] == null && selected != null && selected instanceof Unit) { //move selected entity\r\n            Unit unit = (Unit) selected;\r\n            if(unit.moveTo(position)) {\r\n                entities[selected.getPosition().getX()][selected.getPosition().getY()] = null;\r\n                entities[position.getX()][position.getY()] = selected;\r\n            }\r\n            System.out.println(\"trying to move\");\r\n            selected = null;\r\n        } else if (selected != null && entities[position.getX()][position.getY()] != null\r\n                && entities[position.getX()][position.getY()].getOwner() != currentPlayer) { //attack enemy entity\r\n\r\n        }\r\n        else {\r\n            System.out.println(\"you can't select that token\");\r\n        }\r\n\r\n        //else (the mouse is over a different button)\r\n    }\r\n\r\n    public void keyPressed(char key) {\r\n        if(key == 'w') {\r\n            shift(0, 1);\r\n        }\r\n        else if(key == 'a') {\r\n            shift(1, 0);\r\n        }\r\n        else if(key == 's') {\r\n            shift(0, -1);\r\n        }\r\n        else if(key == 'd') {\r\n            shift(-1, 0);\r\n        }\r\n        if (key == CODED) {\r\n            if (scene.keyCode == UP) {\r\n                zoom(2);\r\n            } else if (scene.keyCode == DOWN) {\r\n                zoom(0.5f);\r\n            }\r\n        }\r\n    }\r\n\r\n    //amount is the\r\n    public void zoom(float amount) {\r\n        //TODO entities do not zoom properly,\r\n        //this requires all entity textures to be accessed somewhere, potentially from GameState potentially\r\n        //from a different manager class for entities\r\n\r\n        if (!(zoomAmount <= 32 && amount < 1)) {\r\n            //zoom for map\r\n            zoomAmount = (int)(zoomAmount * amount);\r\n            map.resize(zoomAmount);\r\n\r\n\r\n            //zoom for entities\r\n            for (Entity[] row: entities) {\r\n                for (Entity element: row) {\r\n                    if(element != null) {\r\n                        element.resize(zoomAmount);\r\n                    }\r\n\r\n                    //scale += amount;\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    //moving around the map, does not take unit movement into account.\r\n    public void shift(int x, int y) {\r\n        //int scale = 1;\r\n\r\n        map.shift(x, y);\r\n\r\n        for (Entity[] row: entities) {\r\n            for (Entity element: row) {\r\n                if(element != null) {\r\n                    element.shift(new Position(element.getPosition().getX() + (x),\r\n                            element.getPosition().getY() + (y)));\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    public void nextTurn(){\r\n        //set remaining move to max\r\n        for (Entity[] row: entities) {\r\n            for (Entity element: row) {\r\n                if(element instanceof Unit) {\r\n                    ((Unit) element).resetMove();\r\n                }\r\n            }\r\n        }\r\n\r\n        //set currentPlayer to next player\r\n        if (players.indexOf(currentPlayer) < players.size() - 1) {\r\n            currentPlayer = players.get(players.indexOf(currentPlayer) + 1);\r\n            System.out.println(\"next turn\");\r\n        } else {\r\n            currentPlayer = players.get(0);\r\n        }\r\n    }\r\n\r\n    public void draw() {\r\n        map.draw(zoomAmount); //drawing the map doesn't need to be color shifted\r\n\r\n        for (Entity[] row: entities) {\r\n            for (Entity entity: row) {\r\n                if(entity != null) {\r\n                    entity.draw(zoomAmount, players.indexOf(entity.getOwner())); //should be color shifted based on player number\r\n                }\r\n            }\r\n        }\r\n\r\n        currentPlayer.draw(); //this is drawing the hud.\r\n    }\r\n\r\n\r\n\r\n//    public static GameState load(Window window, int gameId) throws FileNotFoundException {\r\n//        GameState loadedGameState = new GameState();\r\n//        JSONParser parser = new JSONParser();\r\n//        try(FileReader saveReader = new FileReader(\"saves/save\" + gameId + \".json\")){\r\n//            JSONObject gameStateJSON = (JSONObject)parser.parse(saveReader);\r\n//            loadedGameState.scene = window;\r\n//            loadedGameState.gameId = ((Number)gameStateJSON.get(\"gameId\")).intValue() + 1;\r\n//            loadedGameState.map = Map.fromJSONObject((JSONObject) gameStateJSON.get(\"map\"), window);\r\n//            loadedGameState.currentPlayer = Player.fromJSONObject((JSONObject) gameStateJSON.get(\"currentPlayer\"), window);\r\n//            JSONArray playersArray = (JSONArray) gameStateJSON.get(\"players\");\r\n//            loadedGameState.players = (ArrayList<Player>) playersArray\r\n//                    .stream()\r\n//                    .map(playerObject ->\r\n//                            Player.fromJSONObject((JSONObject)playerObject, window)) //TODO: Maybe remove reference to map or scene from player?\r\n//                    .collect(Collectors.toList());\r\n//            JSONArray entitiesArray = (JSONArray) gameStateJSON.get(\"entities\");\r\n//            loadedGameState.entities = (Entity[][]) entitiesArray\r\n//                    .stream()\r\n//                    .map(row -> {\r\n//                        if (((JSONArray)row).isEmpty()) {\r\n//                            return new Entity[((JSONArray)row).size()]; // Return an empty array with the same size as the row\r\n//                        } else {\r\n//                            return ((JSONArray) row)\r\n//                                    .stream()\r\n//                                    .map((entity) -> Entity.fromJSONObject((JSONObject) entity, window))\r\n//                                    .toArray(Entity[]::new);\r\n//                        }\r\n//                    })\r\n//                    .toArray(Entity[][]::new);\r\n//        } catch (IOException  | ParseException e) {\r\n//            e.printStackTrace();\r\n//        }\r\n//\r\n//        return loadedGameState;\r\n//    }\r\n    /**\r\n     * Saves the current gamestate to a json file in the \"saves\" folder\r\n     * currently called at end of player turn\r\n     */\r\n    public void save(){\r\n        JSONObject gamestate = new JSONObject();\r\n        gamestate.put(\"gameId\", this.gameId);\r\n        gamestate.put(\"map\", map.toJSONObject());\r\n        gamestate.put(\"currentPlayer\", currentPlayer.toJSONObject());\r\n        JSONArray playerArray = new JSONArray();\r\n        for (Player player: players) {\r\n            playerArray.add(player.toJSONObject());\r\n        }\r\n        gamestate.put(\"players\", playerArray);\r\n        JSONArray entityArray = new JSONArray();\r\n        for (Entity[] row: entities) {\r\n            JSONArray rowArray = new JSONArray();\r\n            for (Entity entity: row) {\r\n                if(entity != null) {\r\n                    rowArray.add(entity.toJSONObject());\r\n                } else {\r\n                    rowArray.add(null);\r\n                }\r\n            }\r\n            entityArray.add(rowArray);\r\n        }\r\n        gamestate.put(\"entities\", entityArray);\r\n        try(FileWriter saveFile = new FileWriter(\"saves/save.json\")) {\r\n            saveFile.write(gamestate.toJSONString());\r\n            saveFile.flush();\r\n        } catch (IOException e) {\r\n            e.printStackTrace();\r\n        }\r\n    }\r\n\r\n    public static GameState load(Window window) throws FileNotFoundException {\r\n        GameState loadedGameState = new GameState();\r\n        JSONParser parser = new JSONParser();\r\n        try(FileReader saveReader = new FileReader(\"saves/save.json\")){\r\n            JSONObject gameStateJSON = (JSONObject)parser.parse(saveReader);\r\n            loadedGameState.scene = window;\r\n            loadedGameState.gameId = ((Number)gameStateJSON.get(\"gameId\")).intValue();\r\n            loadedGameState.map = Map.fromJSONObject((JSONObject) gameStateJSON.get(\"map\"), window);\r\n            loadedGameState.currentPlayer = Player.fromJSONObject((JSONObject) gameStateJSON.get(\"currentPlayer\"), window);\r\n            JSONArray playersArray = (JSONArray) gameStateJSON.get(\"players\");\r\n            loadedGameState.players = (ArrayList<Player>) playersArray.stream().map(playerObject -> Player.fromJSONObject((JSONObject)playerObject, window))\r\n                    .collect(Collectors.toList());\r\n            JSONArray entitiesArray = (JSONArray) gameStateJSON.get(\"entities\");\r\n            Entity[][] entities = new Entity[loadedGameState.map.width][loadedGameState.map.width];\r\n            for (int i = 0; i < entitiesArray.size(); i++) {\r\n                JSONArray row = (JSONArray) entitiesArray.get(i);\r\n                for (int j = 0; j < row.size(); j++) {\r\n                    entities[i][j] = Entity.fromJSONObject((JSONObject) row.get(j), window);\r\n                }\r\n            }\r\n            loadedGameState.entities = entities;\r\n        } catch (IOException  | ParseException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n        return loadedGameState;\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/bcit/com2522/project/scuffed/client/GameState.java b/src/main/java/org/bcit/com2522/project/scuffed/client/GameState.java
--- a/src/main/java/org/bcit/com2522/project/scuffed/client/GameState.java	
+++ b/src/main/java/org/bcit/com2522/project/scuffed/client/GameState.java	
@@ -82,8 +82,8 @@
         Position position = new Position((int) (mousePos.x / 32), (int) (mousePos.y / 32));
 
         if (mousePos.x >= 700 && mousePos.y >= 500) { //position of nextTurn button
-            save();
             nextTurn();
+            save();
         }
 
         //TODO everything below this should be mathed out and shortened
@@ -165,7 +165,6 @@
     //moving around the map, does not take unit movement into account.
     public void shift(int x, int y) {
         //int scale = 1;
-
         map.shift(x, y);
 
         for (Entity[] row: entities) {
@@ -212,42 +211,6 @@
     }
 
 
-
-//    public static GameState load(Window window, int gameId) throws FileNotFoundException {
-//        GameState loadedGameState = new GameState();
-//        JSONParser parser = new JSONParser();
-//        try(FileReader saveReader = new FileReader("saves/save" + gameId + ".json")){
-//            JSONObject gameStateJSON = (JSONObject)parser.parse(saveReader);
-//            loadedGameState.scene = window;
-//            loadedGameState.gameId = ((Number)gameStateJSON.get("gameId")).intValue() + 1;
-//            loadedGameState.map = Map.fromJSONObject((JSONObject) gameStateJSON.get("map"), window);
-//            loadedGameState.currentPlayer = Player.fromJSONObject((JSONObject) gameStateJSON.get("currentPlayer"), window);
-//            JSONArray playersArray = (JSONArray) gameStateJSON.get("players");
-//            loadedGameState.players = (ArrayList<Player>) playersArray
-//                    .stream()
-//                    .map(playerObject ->
-//                            Player.fromJSONObject((JSONObject)playerObject, window)) //TODO: Maybe remove reference to map or scene from player?
-//                    .collect(Collectors.toList());
-//            JSONArray entitiesArray = (JSONArray) gameStateJSON.get("entities");
-//            loadedGameState.entities = (Entity[][]) entitiesArray
-//                    .stream()
-//                    .map(row -> {
-//                        if (((JSONArray)row).isEmpty()) {
-//                            return new Entity[((JSONArray)row).size()]; // Return an empty array with the same size as the row
-//                        } else {
-//                            return ((JSONArray) row)
-//                                    .stream()
-//                                    .map((entity) -> Entity.fromJSONObject((JSONObject) entity, window))
-//                                    .toArray(Entity[]::new);
-//                        }
-//                    })
-//                    .toArray(Entity[][]::new);
-//        } catch (IOException  | ParseException e) {
-//            e.printStackTrace();
-//        }
-//
-//        return loadedGameState;
-//    }
     /**
      * Saves the current gamestate to a json file in the "saves" folder
      * currently called at end of player turn
Index: src/main/java/org/bcit/com2522/project/scuffed/client/Window.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package org.bcit.com2522.project.scuffed.client;\r\n\r\nimport org.bcit.com2522.project.scuffed.ui.Menu;\r\nimport org.bcit.com2522.project.scuffed.ui.NewGameMenuState;\r\nimport processing.core.PApplet;\r\nimport processing.core.PVector;\r\n\r\nimport java.io.File;\r\nimport java.io.ObjectInputStream;\r\nimport java.io.ObjectOutputStream;\r\nimport java.net.Socket;\r\n\r\n/**\r\n *\r\n * @author bean\r\n *\r\n */\r\npublic class Window extends PApplet {\r\n\r\n  //Map map;\r\n\r\n  public boolean inGame = false;\r\n\r\n  Menu menu;\r\n\r\n  GameState gameState;\r\n\r\n  Boolean debugMode = false;\r\n  static DebugMenu debugMenu;\r\n  ClickableManager clickableManager;\r\n\r\n  /**server variables**/\r\n  private Socket socket;\r\n  private int clientID;\r\n  private String hostIP;\r\n  private int port;\r\n  private ObjectInputStream ois;\r\n  private ObjectOutputStream oos;\r\n\r\n  /**\r\n   * Called once at the beginning of the program.\r\n   */\r\n  public void settings() {\r\n    size(1080, 720);\r\n  }\r\n\r\n  /**\r\n   * Called once at the beginning of the program.\r\n   * Initializes all objects.\r\n   */\r\n  public void setup() {\r\n    this.init();\r\n  }\r\n\r\n  public void init() {\r\n    //map = new Map(this, 20, 20);\r\n    clickableManager = new ClickableManager(this);\r\n    surface.setTitle(\"Scuffed - Main Menu\");\r\n    menu = new Menu(this);\r\n  }\r\n\r\n  public void initGame(int numplayers, int mapwidth, int mapheight) {\r\n    gameState = new GameState(this, numplayers, mapwidth, mapheight);\r\n    gameState.init();\r\n  }\r\n\r\n  public void initGameServer(int numplayers, int mapwidth, int mapheight) {\r\n    gameState = new GameState(this, numplayers, mapwidth, mapheight);\r\n    gameState.init();\r\n  }\r\n\r\n  @Override\r\n  public void keyPressed() {\r\n    if(inGame) {\r\n      gameState.keyPressed(key);\r\n    }\r\n    if (keyCode == 114) {\r\n      debugMode = !debugMode;\r\n    }\r\n    if(menu.currentState instanceof NewGameMenuState){\r\n        NewGameMenuState newGameMenuState = (NewGameMenuState) menu.currentState;\r\n        newGameMenuState.keyPressed(key);\r\n    }\r\n  }\r\n\r\n  @Override\r\n  public void mouseClicked() {\r\n    if(inGame) {\r\n      PVector mousePos = new PVector(mouseX, mouseY);\r\n      gameState.clicked(mousePos);\r\n      surface.setTitle(\"Scuffed Civ\");\r\n    } else {\r\n      menu.clicked(mouseX, mouseY);\r\n      surface.setTitle(\"Scuffed - \" + menu.currentState.getClass().getSimpleName());\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Called on every frame. Updates scene object\r\n   * state and redraws the scene. Drawings appear\r\n   * in order of function calls.\r\n   */\r\n  public void draw() {\r\n    background(222);\r\n    if(inGame){\r\n      gameState.draw();\r\n    } else {\r\n      menu.draw();\r\n    }\r\n    // Debug Info - Can be added to\r\n    if(debugMode) {\r\n      debugMenu.draw();\r\n    }\r\n  }\r\n\r\n  public ClickableManager getClickableManager() {\r\n    return clickableManager;\r\n  }\r\n\r\n  public void addClickable(Clickable clickable) {\r\n    clickableManager.add(clickable);\r\n  }\r\n\r\n  public void removeClickable(Clickable clickable) {\r\n    clickableManager.remove(clickable);\r\n  }\r\n\r\n  public void loadGame() {\r\n    try {\r\n      this.gameState = GameState.load(this);\r\n    } catch (Exception e) {\r\n      e.printStackTrace();\r\n    }\r\n    inGame = true;\r\n  }\r\n\r\n  /**\r\n   * Main function.\r\n   *\r\n   * @param passedArgs arguments from command line\r\n   */\r\n  public static void main(String[] passedArgs) {\r\n    String[] appletArgs = new String[]{\"eatBubbles\"};\r\n    Window eatBubbles = new Window();\r\n    debugMenu = new DebugMenu(eatBubbles);\r\n    PApplet.runSketch(appletArgs, eatBubbles);\r\n  }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/main/java/org/bcit/com2522/project/scuffed/client/Window.java b/src/main/java/org/bcit/com2522/project/scuffed/client/Window.java
--- a/src/main/java/org/bcit/com2522/project/scuffed/client/Window.java	
+++ b/src/main/java/org/bcit/com2522/project/scuffed/client/Window.java	
@@ -146,5 +146,4 @@
     PApplet.runSketch(appletArgs, eatBubbles);
   }
 
-
 }
\ No newline at end of file
